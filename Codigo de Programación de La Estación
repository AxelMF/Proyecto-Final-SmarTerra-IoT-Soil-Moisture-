> Axel MF:
#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/uart.h"
#include "driver/gpio.h"
#include "esp_log.h"
#include "esp_rom_sys.h"

#define TAG "MODBUS_RAW"

// Pines UART
#define UART_PORT UART_NUM_2
#define UART_TXD 17
#define UART_RXD 16
#define UART_BAUD 4800

#define SLAVE_ADDR 0x01
#define BUF_SIZE 256

#define REG_START 0x0000
#define REG_COUNT 9  // Hum, Temp, EC, pH, N, P, K, Salinity, TDS

// ===== DHT11 =====
#define DHT_PIN 4

static int dht11_read(int *temperature, int *humidity) {
    uint8_t bits[5] = {0};
    uint8_t bitidx = 7, byteidx = 0;
    uint32_t low_time, high_time;

    // Enviar pulso de inicio
    gpio_set_direction(DHT_PIN, GPIO_MODE_OUTPUT);
    gpio_set_level(DHT_PIN, 0);
    vTaskDelay(pdMS_TO_TICKS(20)); // 20 ms en bajo
    gpio_set_level(DHT_PIN, 1);
    esp_rom_delay_us(40);
    gpio_set_direction(DHT_PIN, GPIO_MODE_INPUT);

    // Esperar respuesta
    int count = 0;
    while (gpio_get_level(DHT_PIN) == 1) { if (++count > 85) return -1; esp_rom_delay_us(1); }
    count = 0;
    while (gpio_get_level(DHT_PIN) == 0) { if (++count > 85) return -1; esp_rom_delay_us(1); }
    count = 0;
    while (gpio_get_level(DHT_PIN) == 1) { if (++count > 85) return -1; esp_rom_delay_us(1); }

    // Leer 40 bits
    for (int i = 0; i < 40; i++) {
        // Espera a que empiece pulso alto
        count = 0;
        while (gpio_get_level(DHT_PIN) == 0) { if (++count > 85) return -1; esp_rom_delay_us(1); }
        // Mide la duración del pulso alto
        count = 0;
        while (gpio_get_level(DHT_PIN) == 1) { if (++count > 85) return -1; esp_rom_delay_us(1); }
        // Pulso alto > 40us => bit = 1
        if (count > 40) bits[byteidx] |= (1 << bitidx);
        if (bitidx == 0) { bitidx = 7; byteidx++; }
        else bitidx--;
    }

    // Verificar checksum
    if (bits[4] != ((bits[0] + bits[1] + bits[2] + bits[3]) & 0xFF)) return -2;

    *humidity = bits[0];
    *temperature = bits[2];
    return 0;
}

// ===== CRC16 Modbus =====
uint16_t modbus_crc16(const uint8_t *buf, uint16_t len) {
    uint16_t crc = 0xFFFF;
    for (uint16_t i = 0; i < len; i++) {
        crc ^= buf[i];
        for (int b = 0; b < 8; b++) {
            if (crc & 0x0001) crc = (crc >> 1) ^ 0xA001;
            else crc >>= 1;
        }
    }
    return crc;
}

// ===== Inicialización UART =====
void uart_init_serial(void) {
    const uart_config_t cfg = {
        .baud_rate = UART_BAUD,
        .data_bits = UART_DATA_8_BITS,
        .parity    = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
        .source_clk = UART_SCLK_DEFAULT
    };

    ESP_ERROR_CHECK(uart_driver_install(UART_PORT, BUF_SIZE, BUF_SIZE, 0, NULL, 0));
    ESP_ERROR_CHECK(uart_param_config(UART_PORT, &cfg));
    ESP_ERROR_CHECK(uart_set_pin(UART_PORT, UART_TXD, UART_RXD, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));
}

// ===== Enviar trama Modbus =====
void modbus_send(uint8_t slave, uint16_t start, uint16_t count) {
    uint8_t frame[8];
    frame[0] = slave;
    frame[1] = 0x03; // función Read Holding
    frame[2] = (start >> 8) & 0xFF;
    frame[3] = start & 0xFF;
    frame[4] = (count >> 8) & 0xFF;
    frame[5] = count & 0xFF;
    uint16_t crc = modbus_crc16(frame, 6);
    frame[6] = crc & 0xFF;
    frame[7] = (crc >> 8) & 0xFF;

    uart_write_bytes(UART_PORT, (const char *)frame, sizeof(frame));
    uart_wait_tx_done(UART_PORT, pdMS_TO_TICKS(10));
    ESP_LOGI(TAG, "Trama enviada");
}

// ===== Leer y parsear respuesta =====
void modbus_read_response(uint16_t count) {
    uint8_t buf[BUF_SIZE];
    int len = uart_read_bytes(UART_PORT, buf, BUF_SIZE, pdMS_TO_TICKS(500));
    if (len < 5) {
        ESP_LOGW(TAG, "No hay respuesta o muy corta");
        return;
    }

    // CRC
    uint16_t crc_rx = buf[len-2] | (buf[len-1]<<8);
    uint16_t crc_calc = modbus_crc16(buf, len-2);
    if (crc_rx != crc_calc) {
        ESP_LOGW(TAG, "CRC invalido: rx=0x%04X calc=0x%04X", crc_rx, crc_calc);
        return;
    }
